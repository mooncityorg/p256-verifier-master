{
  "language": "Solidity",
  "sources": {
    "src/P256Verifier.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Force a specific Solidity version for reproducibility.\npragma solidity 0.8.21;\n\n/**\n * This contract verifies P256 (secp256r1) signatures. It matches the exact\n * interface specified in the EIP-7212 precompile, allowing it to be used as a\n * fallback. It's based on Ledger's optimized implementation:\n * https://github.com/rdubois-crypto/FreshCryptoLib/tree/master/solidity\n **/\ncontract P256Verifier {\n    /**\n     * Precompiles don't use a function signature. The first byte of callldata\n     * is the first byte of an input argument. In this case:\n     *\n     * input[  0: 32] = signed data hash\n     * input[ 32: 64] = signature r\n     * input[ 64: 96] = signature s\n     * input[ 96:128] = public key x\n     * input[128:160] = public key y\n     *\n     * result[ 0: 32] = 0x00..00 (invalid) or 0x00..01 (valid)\n     *\n     * For details, see https://eips.ethereum.org/EIPS/eip-7212\n     */\n    fallback(bytes calldata input) external returns (bytes memory) {\n        if (input.length != 160) {\n            return abi.encodePacked(uint256(0));\n        }\n\n        bytes32 hash = bytes32(input[0:32]);\n        uint256 r = uint256(bytes32(input[32:64]));\n        uint256 s = uint256(bytes32(input[64:96]));\n        uint256 x = uint256(bytes32(input[96:128]));\n        uint256 y = uint256(bytes32(input[128:160]));\n\n        uint256 ret = ecdsa_verify(hash, r, s, [x, y]) ? 1 : 0;\n\n        return abi.encodePacked(ret);\n    }\n\n    // Parameters for the sec256r1 (P256) elliptic curve\n    // Curve prime field modulus\n    uint256 constant p =\n        0xFFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF;\n    // Short weierstrass first coefficient\n    uint256 constant a = // The assumption a == -3 (mod p) is used throughout the codebase\n        0xFFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC;\n    // Short weierstrass second coefficient\n    uint256 constant b =\n        0x5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B;\n    // Generating point affine coordinates\n    uint256 constant GX =\n        0x6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296;\n    uint256 constant GY =\n        0x4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5;\n    // Curve order (number of points)\n    uint256 constant n =\n        0xFFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551;\n    // -2 mod p constant, used to speed up inversion and doubling (avoid negation)\n    uint256 constant minus_2modp =\n        0xFFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFD;\n    // -2 mod n constant, used to speed up inversion\n    uint256 constant minus_2modn =\n        0xFFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC63254F;\n\n    /**\n     * @dev ECDSA verification given signature and public key.\n     */\n    function ecdsa_verify(\n        bytes32 message_hash,\n        uint256 r,\n        uint256 s,\n        uint256[2] memory pubKey\n    ) private view returns (bool) {\n        // Check r and s are in the scalar field\n        if (r == 0 || r >= n || s == 0 || s >= n) {\n            return false;\n        }\n\n        if (!ecAff_isOnCurve(pubKey[0], pubKey[1])) {\n            return false;\n        }\n\n        (uint256 sInv, bool sInv_success) = nModInv(s);\n        assert (sInv_success);\n\n        uint256 scalar_u = mulmod(uint256(message_hash), sInv, n); // (h * s^-1) in scalar field\n        uint256 scalar_v = mulmod(r, sInv, n); // (r * s^-1) in scalar field\n\n        (uint256 r_x, bool mulmuladd_success) = ecZZ_mulmuladd(\n            pubKey[0],\n            pubKey[1],\n            scalar_u,\n            scalar_v\n        );\n        return r_x % n == r && mulmuladd_success;\n    }\n\n    /**\n     * @dev Check if a point in affine coordinates is on the curve\n     * Reject 0 point at infinity.\n     */\n    function ecAff_isOnCurve(\n        uint256 x,\n        uint256 y\n    ) internal pure returns (bool) {\n        if (0 == x || x >= p || 0 == y || y >= p) {\n            return false;\n        }\n\n        uint256 LHS = mulmod(y, y, p); // y^2\n        uint256 RHS = addmod(mulmod(mulmod(x, x, p), x, p), mulmod(a, x, p), p); // x^3 + a x\n        RHS = addmod(RHS, b, p); // x^3 + a*x + b\n\n        return LHS == RHS;\n    }\n\n    /**\n     * @dev Computation of uG + vQ using Strauss-Shamir's trick, G basepoint, Q public key\n     * returns tuple of (x coordinate of uG + vQ, boolean that is false if internal precompile staticcall fail)\n     * Strauss-Shamir is described well in https://stackoverflow.com/a/50994362\n     */\n    function ecZZ_mulmuladd(\n        uint256 QX,\n        uint256 QY, // affine rep for input point Q\n        uint256 scalar_u,\n        uint256 scalar_v\n    ) internal view returns (uint256 X, bool success) {\n        uint256 zz = 1;\n        uint256 zzz = 1;\n        uint256 Y;\n        uint256 HX;\n        uint256 HY;\n        bool add_success;\n\n        if (scalar_u == 0 && scalar_v == 0) return (0, true);\n\n        // H = g + Q\n        (HX, HY, add_success) = ecAff_add(GX, GY, QX, QY);\n        assert(add_success);\n\n        int256 index = 255;\n        uint256 bitpair;\n\n        // Find the first bit index that's active in either scalar_u or scalar_v.\n        while(index >= 0) {\n            bitpair = compute_bitpair(uint256(index), scalar_u, scalar_v);\n            index--;\n            if (bitpair != 0) break;\n        }\n\n        // initialise (X, Y) depending on the first active bitpair.\n        // invariant(bitpair != 0); // bitpair == 0 is only possible if u and v are 0.\n        \n        if (bitpair == 1) {\n            (X, Y) = (GX, GY);\n        } else if (bitpair == 2) {\n            (X, Y) = (QX, QY);\n        } else if (bitpair == 3) {\n            (X, Y) = (HX, HY);\n        }\n\n        uint256 TX;\n        uint256 TY;\n        while(index >= 0) {\n            (X, Y, zz, zzz) = ecZZ_double_zz(X, Y, zz, zzz);\n\n            bitpair = compute_bitpair(uint256(index), scalar_u, scalar_v);\n            index--;\n\n            if (bitpair == 0) {\n                continue;\n            } else if (bitpair == 1) {\n                (TX, TY) = (GX, GY);\n            } else if (bitpair == 2) {\n                (TX, TY) = (QX, QY);\n            } else {\n                (TX, TY) = (HX, HY);\n            }\n\n            (X, Y, zz, zzz) = ecZZ_dadd_affine(X, Y, zz, zzz, TX, TY);\n        }\n\n        uint256 zzInv;\n        (zzInv, success) = pModInv(zz);\n        X = mulmod(X, zzInv, p); // X/zz\n    }\n\n    /**\n     * @dev Compute the bits at `index` of u and v and return\n     * them as 2 bit concatenation.\n     * todo: add example\n     */\n    function compute_bitpair(uint256 index, uint256 scalar_u, uint256 scalar_v) internal pure returns (uint256 ret) {\n        ret = (((scalar_v >> index) & 1) << 1) + ((scalar_u >> index) & 1);\n    }\n\n    /**\n     * @dev Add two elliptic curve points in affine coordinates\n     * Assumes points are on the EC\n     */\n    function ecAff_add(\n        uint256 x1,\n        uint256 y1,\n        uint256 x2,\n        uint256 y2\n    ) internal view returns (uint256, uint256, bool) {\n        // invariant(ecAff_IsZero(x1, y1) || ecAff_isOnCurve(x1, y1));\n        // invariant(ecAff_IsZero(x2, y2) || ecAff_isOnCurve(x2, y2));\n\n        uint256 zz1;\n        uint256 zzz1;\n\n        if (ecAff_IsZero(x1, y1)) return (x2, y2, true);\n        if (ecAff_IsZero(x2, y2)) return (x1, y1, true);\n\n        (x1, y1, zz1, zzz1) = ecZZ_dadd_affine(x1, y1, 1, 1, x2, y2);\n\n        return ecZZ_SetAff(x1, y1, zz1, zzz1);\n    }\n\n    /**\n     * @dev Check if the curve is the zero curve in affine rep\n     * Assumes point is on the EC or is the zero point.\n     */\n    function ecAff_IsZero(\n        uint256,\n        uint256 y\n    ) internal pure returns (bool flag) {\n        // invariant((x == 0 && y == 0) || ecAff_isOnCurve(x, y));\n\n        return (y == 0);\n    }\n\n    /**\n     * @dev Add a ZZ point to an affine point and return as ZZ rep\n     * Uses madd-2008-s and mdbl-2008-s internally\n     * https://hyperelliptic.org/EFD/g1p/auto-shortw-xyzz-3.html#addition-madd-2008-s\n     * Matches https://github.com/supranational/blst/blob/9c87d4a09d6648e933c818118a4418349804ce7f/src/ec_ops.h#L705 closely\n     * Handles points at infinity gracefully\n     */\n    function ecZZ_dadd_affine(\n        uint256 x1,\n        uint256 y1,\n        uint256 zz1,\n        uint256 zzz1,\n        uint256 x2,\n        uint256 y2\n    ) internal pure returns (uint256 x3, uint256 y3, uint256 zz3, uint256 zzz3) {\n        if (y2 == 0) { // (X2, Y2) is point at infinity\n            if (zz1 == 0 && zzz1 == 0) return ecZZ_PointAtInf();\n            return (x1, y1, zz1, zzz1);\n        } else if (zz1 == 0 && zzz1 == 0) { // (X1, Y1) is point at infinity\n            return (x2, y2, 1, 1);\n        }\n\n        uint256 comp_R = addmod(mulmod(y2, zzz1, p), p - y1, p); // R = S2 - y1 = y2*zzz1 - y1\n        uint256 comp_P = addmod(mulmod(x2, zz1, p), p - x1, p); // P = U2 - x1 = x2*zz1 - x1\n\n        if (comp_P != 0) { // X1 != X2\n            // invariant(x1 != x2);\n            uint256 comp_PP = mulmod(comp_P, comp_P, p); // PP = P^2\n            uint256 comp_PPP = mulmod(comp_PP, comp_P, p); // PPP = P*PP\n            zz3 = mulmod(zz1, comp_PP, p); //// ZZ3 = ZZ1*PP\n            zzz3 = mulmod(zzz1, comp_PPP, p); //// ZZZ3 = ZZZ1*PPP\n            uint256 comp_Q = mulmod(x1, comp_PP, p); // Q = X1*PP\n            x3 = addmod(\n                addmod(mulmod(comp_R, comp_R, p), p - comp_PPP, p), // (R^2) + (-PPP)\n                mulmod(minus_2modp, comp_Q, p), // (-2)*(Q)\n                p\n            ); // R^2 - PPP - 2*Q\n            y3 = addmod(\n                mulmod(addmod(comp_Q, p - x3, p), comp_R, p), //(Q+(-x3))*R\n                mulmod(p - y1, comp_PPP, p), // (-y1)*PPP\n                p\n            ); // R*(Q-x3) - y1*PPP\n        } else if (comp_R == 0) { // X1 == X2 and Y1 == Y2\n            // invariant(x1 == x2 && y1 == y2);\n\n            // Must be affine because (X2, Y2) is affine.\n            (x3, y3, zz3, zzz3) = ecZZ_double_affine(x2, y2);\n        } else { // X1 == X2 and Y1 == -Y2\n            // invariant(x1 == x2 && y1 == p - y2);\n            (x3, y3, zz3, zzz3) = ecZZ_PointAtInf();\n        }\n\n        return (x3, y3, zz3, zzz3);\n    }\n\n    /**\n     * @dev Double a ZZ point \n     * Uses http://hyperelliptic.org/EFD/g1p/auto-shortw-xyzz.html#doubling-dbl-2008-s-1\n     * Handles point at infinity gracefully\n     */\n    function ecZZ_double_zz(uint256 x1,\n        uint256 y1, uint256 zz1, uint256 zzz1) internal pure returns (uint256 x3, uint256 y3, uint256 zz3, uint256 zzz3) {\n        if (zz1 == 0 && zzz1 == 0) return ecZZ_PointAtInf();\n        if (zz1 == 1 && zzz1 == 1) return ecZZ_double_affine(x1, y1);\n    \n        uint256 comp_U = mulmod(2, y1, p); // U = 2*Y1\n        uint256 comp_V = mulmod(comp_U, comp_U, p); // V = U^2\n        uint256 comp_W = mulmod(comp_U, comp_V, p); // W = U*V\n        uint256 comp_S = mulmod(x1, comp_V, p); // S = X1*V\n        uint256 comp_M = addmod(mulmod(3, mulmod(x1, x1, p), p), mulmod(a, mulmod(zz1, zz1, p), p), p); //M = 3*(X1)^2 + a*(zz1)^2\n        \n        x3 = addmod(mulmod(comp_M, comp_M, p), mulmod(minus_2modp, comp_S, p), p); // M^2 + (-2)*S\n        y3 = addmod(mulmod(comp_M, addmod(comp_S, p - x3, p), p), mulmod(p - comp_W, y1, p), p); // M*(S+(-X3)) + (-W)*Y1\n        zz3 = mulmod(comp_V, zz1, p); // V*ZZ1\n        zzz3 = mulmod(comp_W, zzz1, p); // W*ZZZ1\n    }\n\n    /**\n     * @dev Double an affine point and return as a ZZ point \n     * Uses http://hyperelliptic.org/EFD/g1p/auto-shortw-xyzz.html#doubling-mdbl-2008-s-1\n     * Handles point at infinity gracefully\n     */\n    function ecZZ_double_affine(uint256 x1,\n        uint256 y1) internal pure returns (uint256 x3, uint256 y3, uint256 zz3, uint256 zzz3) {\n        if (y1 == 0) return ecZZ_PointAtInf();\n\n        uint256 comp_U = mulmod(2, y1, p); // U = 2*Y1\n        zz3 = mulmod(comp_U, comp_U, p); // V = U^2 = zz3\n        zzz3 = mulmod(comp_U, zz3, p); // W = U*V = zzz3\n        uint256 comp_S = mulmod(x1, zz3, p); // S = X1*V\n        uint256 comp_M = addmod(mulmod(3, mulmod(x1, x1, p), p), a, p); // M = 3*(X1)^2 + a\n        \n        x3 = addmod(mulmod(comp_M, comp_M, p), mulmod(minus_2modp, comp_S, p), p); // M^2 + (-2)*S\n        y3 = addmod(mulmod(comp_M, addmod(comp_S, p - x3, p), p), mulmod(p - zzz3, y1, p), p); // M*(S+(-X3)) + (-W)*Y1\n    }\n\n    /**\n     * @dev Convert from ZZ rep to affine rep\n     * Assumes (zz)^(3/2) == zzz (i.e. zz == z^2 and zzz == z^3)\n     * See https://hyperelliptic.org/EFD/g1p/auto-shortw-xyzz-3.html\n     */\n    function ecZZ_SetAff(\n        uint256 x,\n        uint256 y,\n        uint256 zz,\n        uint256 zzz\n    ) internal view returns (uint256 x1, uint256 y1, bool success) {\n        if(zz == 0 && zzz == 0) {\n            (x1, y1) = ecAffine_PointAtInf();\n            return (x1, y1, true);\n        }\n\n        (uint256 zzzInv, bool zzzInv_success) = pModInv(zzz); // 1 / zzz\n        uint256 zInv = mulmod(zz, zzzInv, p); // 1 / z\n        uint256 zzInv = mulmod(zInv, zInv, p); // 1 / zz\n\n        // invariant(mulmod(FCL_pModInv(zInv), FCL_pModInv(zInv), p) == zz)\n        // invariant(mulmod(mulmod(FCL_pModInv(zInv), FCL_pModInv(zInv), p), FCL_pModInv(zInv), p) == zzz)\n\n        x1 = mulmod(x, zzInv, p); // X / zz\n        y1 = mulmod(y, zzzInv, p); // y = Y / zzz\n        success = zzzInv_success;\n    }\n\n    /**\n     * @dev Point at infinity in ZZ rep\n     */\n    function ecZZ_PointAtInf() internal pure returns (uint256, uint256, uint256, uint256) {\n        return (0, 0, 0, 0);\n    }\n\n    /**\n     * @dev Point at infinity in affine rep\n     */\n    function ecAffine_PointAtInf() internal pure returns (uint256, uint256) {\n        return (0, 0);\n    }\n\n    /**\n     * @dev u^-1 mod n\n     */\n    function nModInv(uint256 u) internal view returns (uint256 result, bool success) {\n        return modInv(u, n, minus_2modn);\n    }\n\n    /**\n     * @dev u^-1 mod p\n     */\n    function pModInv(uint256 u) internal view returns (uint256 result, bool success) {\n        return modInv(u, p, minus_2modp);\n    }\n\n    /**\n     * @dev u^-1 mod f = u^(phi(f) - 1) mod f = u^(f-2) mod f for prime f\n     * by Fermat's little theorem, compute u^(f-2) mod f using modexp precompile\n     * Assume f != 0.\n     */\n    function modInv(uint256 u, uint256 f, uint256 minus_2modf) internal view returns (uint256 result, bool success) {\n        // invariant(f != 0);\n        // invariant(f prime);\n\n        // This seems like a relatively standard way to use this precompile:\n        // https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3298/files#diff-489d4519a087ca2c75be3315b673587abeca3b302f807643e97efa7de8cb35a5R427\n\n        bytes memory ret;\n        (success, ret) = (address(0x05).staticcall(abi.encode(32, 32, 32, u, minus_2modf, f)));\n        result = abi.decode(ret, (uint256));\n    }\n}\n"
    }
  },
  "settings": {
    "remappings": [
      "forge-std/=lib/forge-std/src/",
      "ds-test/=lib/forge-std/lib/ds-test/src/"
    ],
    "optimizer": {
      "enabled": true,
      "runs": 999999
    },
    "viaIR": true,
    "metadata": {
      "useLiteralContent": false,
      "bytecodeHash": "ipfs",
      "appendCBOR": true
    },
    "outputSelection": {
      "*": {
        "": [
          "ast"
        ],
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata"
        ]
      }
    },
    "evmVersion": "paris",
    "libraries": {}
  }
}